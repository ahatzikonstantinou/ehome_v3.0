$def with (mqtt_servers, containers, domains, item_types, items, language)
$var page = "index" # used in menu.html to hide/show the language dropdown based on page
$var language = language #so that it is available for menu.html base template
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>eHome</title>

    <link rel="stylesheet" href="/static/css/bootstrap.css">
    <link rel="stylesheet" href="/static/css/bootstrap-toggle.min.css">
    <link rel="stylesheet" href="/static/css/materialdesignicons.min.css">

    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="stylesheet" href="/static/css/old.css">
    <script src="/static/scripts/paho-mqtt.min.js"></script>

    <script src="/static/scripts/devices/mqtt_device.js"></script>
    <script src="/static/scripts/devices/alarm.js"></script>
    <script src="/static/scripts/devices/door1.js"></script>
    <script src="/static/scripts/devices/door2r.js"></script>
    <script src="/static/scripts/devices/ipcamera.js"></script>
    <script src="/static/scripts/devices/ipcameraPanTilt.js"></script>
    <script src="/static/scripts/devices/light1.js"></script>
    <script src="/static/scripts/devices/light2.js"></script>
    <!-- <script src="/static/scripts/devices/modem.js"></script> -->
    <script src="/static/scripts/devices/motionCamera.js"></script>
    <script src="/static/scripts/devices/motionCameraPanTilt.js"></script>
    <script src="/static/scripts/devices/net.js"></script>
    <script src="/static/scripts/devices/roller1.js"></script>
    <script src="/static/scripts/devices/roller1_auto.js"></script>
    <script src="/static/scripts/devices/server.js"></script>
    <script src="/static/scripts/devices/switch.js"></script>
    <script src="/static/scripts/devices/temperature_humidity.js"></script>
    <script src="/static/scripts/devices/water-pump.js"></script>
    <script src="/static/scripts/devices/watertank.js"></script>
    <link rel="stylesheet" href="/static/css/watertank.css">
    <script src="/static/scripts/devices/window1.js"></script>
    <script src="/static/scripts/devices/window1r.js"></script>
    <script src="/static/scripts/devices/window2r.js"></script>
    <script src="/static/scripts/devices/motion-sensor.js"></script>

    <script>
        // mqttServer data
        var hiddenServers = []; //will hold the actual servers. Later in window.load the servers
                                // array will hold proxies of the server objects in order to 
                                // update the screen when a property of the server changes.
        var mqttServers = [
            $for server in mqtt_servers:
                new Server(
                    $(loop.index0), 
                    "$server['address']", 
                    "$server['port']", 
                    "$server['ws_port']", 
                    "$(server['username'] if server['username'] is not None else "null" )", 
                    "$(server['password'] if server['password'] is not None else "null" )"                    
                ),                
        ];

        var containersList = [
            $for container in containers:
                { id: $(loop.index-1), containerName: "$container['containerName']", parentContainer: "$(container['parentContainer'] if container['parentContainer'] is not None else "null" )", guid: "$container['guid']" },
        ];
        // replace string null with actual null
        containersList.forEach(function(c){
            if( c.parentContainer == "null" )
            {
                c.parentContainer = null;
            }
        })

        var item_types = [
            $for item_type in item_types:
                { id: "$item_type['id']", description:"$item_type['description']" },
        ];
                
        var items = [
            $for item in items:
                { 
                    id: $(loop.index0), 
                    name: "$item['itemName']", 
                    itemMqttServer: $item['itemMqttServer'], 
                    itemContainer: "$item['itemContainer']", 
                    type: "$item['itemType']", 
                    publish: "$item['publish']",
                    subscribe: "$item['subscribe']",
                    filterById: $('true' if item['filterById'] else 'false'),
                    idFilterValue: "$item['idFilterValue']",
                    state: "UNKNOWN",
                    showDeviceCommands: false,
                    // for cameras
                    url: null,
                    baseUrl: null,
                    videostream: null,
                    right: null,
                    left: null,
                    up: null,
                    down: null,
                    stop: null,                    
                    cameraId: null,
                    guiFilter: function(filterProperty){
                        for(let i = 0 ; i < containers.length ; i++)
                        {
                            const rootContainer = findContainer(containers[i], this.itemContainer);
                            if(rootContainer != null)
                            {
                                // console.log("Found root container of item ", this);
                                return containers[i].gui.filter[filterProperty];
                            }
                        }
                        throw new Error("Root container for item ", this, " not found.");
                    }
                },
        ];
        
        var filter = {
                        DOOR: true,
                        WINDOW: true,
                        LIGHT: true,
                        CLIMATE: true,
                        COVER: true,
                        ALARM: true,
                        CAMERA: true,
                        MOTION: true,
                        WATERTANK: true,
                        SWITCH: true,
                        WATER_PUMP: true
                    };

        var deviceHtmlTemplateCache = [];

        //
        //
        // MQTT related vars and function
        //
        const client = {};  // a dictionary for the Paho client of each mqtt server

        function connectToMqtt(server) {
            console.log(server);
            server.connect();
        }

        function onConnect(connectOptions) {
            let server = connectOptions.invocationContext;
            server.connection.type = 'CONNECTED';
            console.log("Connected to ", server);
            server.updateConnected();

            // console.log("Connected to MQTT server " + connectOptions.invocationContext['address'] + ":" + connectOptions.invocationContext['ws_port']);
            // client[connectOptions.invocationContext['address']+":"+connectOptions.invocationContext['ws_port']].subscribe("test/topic");

            
            items.forEach(i => {
                // create the array of subscribed devices if no device has been subscribed yet
                if(server.subscribptions[i.publish] == null || server.subscribptions[i.publish] == undefined)
                {
                    server.subscribptions[i.publish] = [];
                    console.log("creating subscriptions dictionary entry for topic: " + i.publish);
                }
            
                server.subscribptions[i.publish].push(i.device);  // register the device for this topic
                client[server.key()].subscribe(i.publish);        // subscribe to the device's publish topic
            
                i.device.setPublisher(client[server.key()]); // tell each device that this client is its publisher for sending mqtt messages
            });
        }

        function onConnectionLost(responseObject) {
            if (responseObject.errorCode !== 0) {
                let server = mqttServers.filter(s => s.key() == (this.host + ":" + this.port))[0];
                server.connection.type = 'NOT_CONNECTED';
                console.log("Connection lost:", responseObject.errorMessage, " on server: ", server);
            }
        }

        function onFailure(errorMessage) {
            console.error('Failed to connect to MQTT broker. Error: ' + errorMessage.errorMessage, ", this: ", this);
            let server = this.invocationContext;
            server.updateDisconnected();
        }
 
        var configuration_str = "";
        function onMessageArrived(message) {
            // console.log("this: ", this);
            // console.log("new message: " + message.topic + message.payloadString, message);
            let server = mqttServers.filter(s => s.key() == (this.host + ":" + this.port))[0];
            server.subscribptions[message.topic].forEach(d => d.update(message.topic, message.payloadString));
            server.updateConnected();
            return;

            if(message.payloadString != configuration_str)
            {
                console.log("New configuration.");
                try
                {
                    // in case we are called after a configuration refresh, first disconnect already conencted clients
                    for (const [key, value] of Object.entries(client)) 
                    {
                        if(value != null && value != undefined)
                        {
                            console.log(`Disconnecting from mqtt server: $${key}, client: $${value}`);
                            value.disconnect();
                        }
                    }
                }
                catch(e)
                {
                    console.error(e);
                }

                configuration_str = message.payloadString;
                let configuration = JSON.parse(configuration_str);
                mqttServers = configuration.mqttServers;
                containersList = configuration.containers;
                item_types = configuration.item_types;
                items = configuration.items;                
                initContent();
            }
            else
            {
                console.log("Configuration unchanged.");
            }
        }
    
        //
        // end of MQTT related vars and function
        //
        //

        //
        //
        // add new custom elements here, along with any attributes that must be replaced by context and values
        // and passed on to the elements inside the correspnding html template
        //
        const customElementDirectives = [
            {
                elements: ["server"],
                attributesToContext: [{ attribute: "server", contextProperty: 'server'}]
            },
            {
                elements: ["container"], 
                attributesToContext: [
                    { attribute: "container", contextProperty: 'c'},
                    { attribute: "level", contextProperty: 'level'},
                    { attribute: "show-label", contextProperty: 'showLabel'},
                    { attribute: "expandAllChildren", contextProperty: 'expandAllChildren'},
                    { attribute: "is-collapsed-house", contextProperty: 'isCollapsedHouse'},
                    { attribute: "filter", contextProperty: 'filter'},
                    { attribute: "show-mqtt-topics", contextProperty: 'showMqttTopics'}
                ]
            },
            {
                elements: ["item", "alarm", "door1", "door2r", "window1", "window1r", "window2r", "light1", "light2", "ipcamera", "ipcamera-pan-tilt", "motion-camera", "motion-camera-pan-tilt", "temphum", "net", "roller1", "roller1auto", "water-pump",  "watertank", "motion-sensor", "switch"], 
                attributesToContext: [
                    { attribute: "item", contextProperty: 'i'},
                    { attribute: "filter", contextProperty: 'filter'},
                    { attribute: "is-collapsed-house", contextProperty: 'isCollapsedHouse'},
                    { attribute: "is-collapsed-floor", contextProperty: 'isCollapsedFloor'},
                    { attribute: "is-collapsed-room", contextProperty: 'isCollapsedRoom'},
                    { attribute: "show-mqtt-topics", contextProperty: 'showMqttTopics'}

                ]
            }                
        ];

        // Observe changes in variables and recompile directives accordingly
        var containers = [];
        var hiddenContainers = [];
        
        var proxyContainerRecompileNgClass = false;
        
        // other proxied objects that will trigger recompile of ngClass
        var otherProxies = [];

        window.onload = function () {
            console.log("window.onload");
            initContent();
        };

        function initContent()
        {
            proxyContainerRecompileNgClass = false;
            mqttServers.forEach(connectToMqtt);
            
            items.forEach(i => { addDeviceToItem(i);});
            console.log("items: ", items);

            hiddenContainers = generateContainerItemTree(containersList, null);
            containers = []; // these will be the proxies
            hiddenContainers.forEach(hc => { containers.push(createProxiedContainer(hc)); });

            hiddenServers = mqttServers;
            mqttServers = [];
            hiddenServers.forEach(s => { mqttServers.push( createProxiedContainer(s) ); });

            while(documentContainsNgRepeat() || documentContainsReplaceableCustomElements())
            // for(let i = 0 ; i < 3 ; i++)
            {
                console.log((documentContainsNgRepeat() || documentContainsReplaceableCustomElements()));
                compileNgIf();
                compileNgRepeat();
                compileCustomElements();
            }
            // compileNgInit(); see TODO comment inside compileNgInit()
            compileNgId();
            compileNgTextContent();
            compileNgShow();
            compileUibCollapse();
            compileNgClass();
            evalValues(document.getElementById('content'));
            compileNgClick();
            compileNgDisabled();
            compileTranslations();
            
            proxyContainerRecompileNgClass = true;
            // console.log("full text: ", document.getElementById("content").innerHTML);            
        }

        function createProxy(obj) {
            // no proxy for dates, it does not work
            if(obj instanceof Date)
            {
                throw new Error("Cannot proxy dates. Object " , obj, " must be replaced by a string and date manipulation must be done converting back and forth between Date and string.");
            }

            return new Proxy(obj, {
                get(target, property, receiver) {
                    const value = Reflect.get(target, property, receiver);
                    if(property instanceof Date)
                    {
                        console.log("receiver: ", receiver);
                        console.log(`Getting $${property}: `,value);
                    }
                    return value;
                },
                set(target, property, value, receiver) {
                    // console.log(`Setting $${property} to `,value);
                    const success = Reflect.set(target, property, value, receiver);
                    if (success) {
                        // console.log("set operaton was successfull, proxyContainerRecompileNgClass: " + proxyContainerRecompileNgClass);
                        if(proxyContainerRecompileNgClass)
                        {
                            compileNgIf();
                            compileUibCollapse();
                            compileNgShow();
                            compileNgClass();
                            compileNgDisabled();
                            compileNgTextContent();
                            compileTranslations();
                        }
                    }
                    return success;
                }
            });
        }

        function createProxiedContainer(obj) {
            // Create a proxy for the object itself
            // it is good not just for containers but for any object with other
            // nested objects as properties
            const proxiedObject = createProxy(obj);

            // Create proxies for each property that is an object or an array
            for (const key in proxiedObject) {
                if (typeof proxiedObject[key] === 'object' && proxiedObject[key] !== null) {
                    proxiedObject[key] = createProxiedContainer(proxiedObject[key]);
                }
            }

            return proxiedObject;
        }

        function documentContainsReplaceableCustomElements()
        {
            const ces = document.querySelectorAll(customElementDirectives.map((ced) => {return ced.elements;}).flat().join(", "));
            if(ces.length == 0)
            {
                return false;
            }

            let htmlFilesExist = true;
            ces.forEach((c) => {
                let text = getContentsFromFile('static/elements/' + c.localName + '.html');
                htmlFilesExist = htmlFilesExist && text.found;
            })
            return htmlFilesExist;
        }

        function documentContainsNgRepeat()
        {
            return document.querySelectorAll('[ng-repeat]').length > 0;
        }

        function collectAttributes(node, attributes, textNodes) {
            // Collect attributes from the current element in order to update their values
            // by replacing variables appearing as isolated scope in custom elements
            // console.log("node: ", node, " has " + node.attributes.length + " attribues: ", node.attributes);
            if (node.nodeType === Node.ELEMENT_NODE && node.attributes.length > 0){
                for (let i = 0; i < node.attributes.length; i++) {
                    const attribute = node.attributes[i];
                    if (attribute.name.startsWith('ng-') ||
                        attribute.name === "data-translate" ||
                        attribute.name === "uib-collapse" ||
                        customElementDirectives.map(c => c.attributesToContext.map(a => a.attribute))
                            .flat()
                            .some(a => a.toLowerCase() === attribute.name.toLowerCase() )
                    ) {
                        attributes.push(attribute);
                    }
                }
            }

            // If the node is a text node, collect it
            if (node.nodeType === Node.TEXT_NODE && node.textContent.includes("{{")) {
                textNodes.push(node);                
            }

            // Recursively collect attributes from child nodes
            // console.log("element: ", element, " has " + element.children.length + ": ", element.children);
            if (node.hasChildNodes()) {
                for (let i = 0; i < node.childNodes.length; i++) {
                    collectAttributes(node.childNodes[i], attributes, textNodes);
                }
            }
        }

        function replaceWordAWithWordB(template, wordA, wordB) {
            // Example usage:
            // const template = document.createElement('div');
            // template.innerHTML = `
            //     <div ng-attr1="wordA" ng-attr2="wordA">wordA.wordA</div>
            //     <div>{{expression1 + wordA}}</div>
            //     <div>{{expression2 + wordA}}</div>
            // `;
            // const wordA = "wordA";
            // const wordB = "wordB";
            // replaceWordAWithWordB(template, wordA, wordB);
            // console.log(template.outerHTML);

            const attributes = [];
            const textNodes = [];
            collectAttributes(template, attributes, textNodes);
            // console.log("collected attributes: ", attributes);
            // console.log("collected textNodes: ", textNodes);
            const content = template.innerHTML;

            // console.log("replacing '" + wordA + "' with '" + wordB + "' in all collected attributes");
            // Loop through all attributes
            for (let i = 0; i < attributes.length; i++) {
                const attributeName = attributes[i].name;
                const attributeValue = attributes[i].value;

                // Replace wordA with wordB in attribute values
                // const replacedAttributeValue = attributeValue.replace(new RegExp(`([^.]|^)$${wordA}([^.]|$$)`, 'g'), function(match, before, after) {
                //     return before + wordB + after;
                // });
                const replacedAttributeValue = attributeValue.replace(new RegExp(`(?<!\\.)\\b$${wordA}\\b`, 'g'), wordB);

                // Update the attribute value
                // console.log("updating " + attributeName + ", old value: '" + attributeValue + "', new value: '" + replacedAttributeValue + "'" );
                attributes[i].value = replacedAttributeValue;
            }
            // console.log("template now is: ", template.innerHTML);
            // Replace wordA with wordB in content (within '{{' and '}}')
            textNodes.forEach(t =>{
                t.textContent = t.textContent.replace(new RegExp(`(?<!\\{\\{.*\\.)\\b$${wordA}\\b(?=.*\\}\\})`, 'g'), wordB);
            });
            // console.log("collected attributes after replacement: ", attributes);

            // const replacedContent = template.innerHTML.replace(new RegExp(`(?<!\\.{{.*)\\b$${wordA}\\b(?=.*}}(?!.*}})`, 'g'), wordB);
            
            // const replacedContent = content.replace(new RegExp(`{{(.*?)$${wordA}(.*?)}}`, 'g'), function(match, before, after) {
            //     return `{{$${before}$${wordB}$${after}}}`;
            // });

            // Update the content
            // template.innerHTML = replacedContent;
        }

        function compileCustomElements()
        {
            const elements = document.querySelectorAll(customElementDirectives.map((ced) => {return ced.elements;}).flat().join(", "));
            elements.forEach((element) => {
                // console.log("attributes: ", element.attributes, " of element:", element);                
                let text = getContentsFromFile('static/elements/' + element.localName + '.html');
                if(!text.found)
                {
                    console.log('No html file found for ' + element.localName + ' in static/elements');
                    return true;
                }
                // console.log("text from file: " + text.response);
                let template = document.createElement('template');
                template.innerHTML = text.response;

                customElementDirectives
                .find(cd => {return cd.elements.indexOf(element.localName) > -1;})
                .attributesToContext.forEach(a2c =>{
                    // console.log("template was: " + template.innerHTML);
                    // copy computed values of attributes already stored in context with key = attribute.name
                    // into new (or existing) context keys for use in children of element
                    let oldValue = element.getAttribute(a2c.attribute);
                    let replacementValue = oldValue;
                    if(oldValue != null)
                    {
                        // console.log(a2c.attribute + " old value: " + oldValue);
                        const evaluatedValue = evaluateAndCheckPrimitive(oldValue);
                        if(!evaluatedValue.error && evaluatedValue.isPrimitive)
                        {
                            // console.log("newValue: " + newValue.result );
                            // element.setAttribute(a2c.attribute, newValue.result);
                            replacementValue = "(" + element.getAttribute(a2c.attribute) + ")"
                        }
                    }

                    replaceWordAWithWordB(template.content, a2c.contextProperty, replacementValue);
                    // console.log("template now is: " + template.innerHTML);
                });
               
                element.parentNode.appendChild(template.content.cloneNode(true));
                element.remove();
            });
        }

        function compileNgInit() {
            // TODO: this does not really work. Besides all variables declared in ng-init
            // are device specific flags used to indicate if some device property should be
            // displayed, mainly in camera elements. Move these variables into the device.
            const elements = document.querySelectorAll('[ng-init]');
            elements.forEach(element => {
                const expression = element.getAttribute('ng-init');

                const scope = {}; // Create an object to represent the scope

                // Evaluate the expression in the scope context
                // Here, we use an immediately invoked function expression (IIFE) to create a local scope
                // (function(scope) {
                    // Use eval() to evaluate the expression in the scope context
                    try
                    {
                        // define arrays before assignment
                        const arrays = expression.split(";").map(s => {a = s.split("=")[0].trim(); if(a.indexOf("[") > -1) return a.split("[")[0]; else return null;}).filter(a => a != null && a != undefined).forEach(v => {
                            let defExpr = "" + v + "=[];";
                            defExpr += "otherProxies.push(createProxiedContainer." + v +");";
                            console.log("compileNgInit declares array: '" + defExpr + "'");
                            console.log(eval(defExpr));
                        });

                        console.log("compileNgInit evals init: '" + expression + "'");
                        eval(expression);
                    }
                    catch(e)
                    {
                        console.warn("Error in compileNgInit for eval expr: '" + expression + "'");
                        throw(e);
                    }
                // })(scope);

                // Copy variables from the scope object to the current scope
                for (const key in scope) {
                    if (scope.hasOwnProperty(key)) {
                        window[key] = scope[key];
                    }
                }
            });
        }

        function compileNgTextContent() {
            // replace the textContent of an element with the evaluated expression
            const elements = document.querySelectorAll('[ng-textContent]');
            elements.forEach(element => {
                let expr = element.getAttribute('ng-textContent');
                // console.log('ng-textContext : ' + expr);
                element.textContent = evaluateExpression(expr);
            });
        }
        
        function compileNgClick() {
            const elements = document.querySelectorAll('[ng-click]');
            elements.forEach(element => {
                const clickHandler = element.getAttribute('ng-click');
                if (!!clickHandler) {
                    // console.log("adding click eventListenr '" + clickHandler + "' to element: ", element);
                    element.addEventListener('click', function() {
                        // console.log("eval clickHandler: ", clickHandler);
                        eval(clickHandler);
                    });
                }
            });
        }

        function compileNgClass() {
            const elements = document.querySelectorAll('[ng-class]');
            elements.forEach(element => {
                const ngClass = "{" + element.getAttribute('ng-class').slice(1,-1).split(",").map(s => s.split(":").map(s => s.trim())).map(s => {return s[0].split("'").join("\"") + " : \"" + s[1] +"\"";}).join(", ") + "}";
                try
                {
                    // console.log("ngClass '" + ngClass + "' for element: ", element);
                    const classesObject = JSON.parse(ngClass);
                    Object.keys(classesObject).forEach(className => {
                        const condition = eval(classesObject[className]);
                        className.split(" ").forEach(cn => {
                        if (condition) {
                                element.classList.add(cn);
                            } else {
                                element.classList.remove(cn);
                            }
                        });
                    });
                }
                catch(e)
                {
                    console.warn("Error in compileNgClass for ngClass='" + ngClass + "'");
                    throw(e);
                }
            });
        }

        function compileNgRepeat() {
            const elements = document.querySelectorAll('[ng-repeat]');
            elements.forEach(element => {
                const ngRepeat = element.getAttribute('ng-repeat');
                if (ngRepeat) {
                    const parts = ngRepeat.split(' in ');
                    const singleItemExpression = parts[0].trim();
                    const itemCollectionExpression = parts[1].trim();
                    // console.log("singleItemExpression: '" + singleItemExpression + "', itemCollectionExpression: '" + itemCollectionExpression + "'");
                    const items = evaluateExpression(itemCollectionExpression);
                    items.forEach((item,i) => {
                        const newItem = element.cloneNode(true);
                        newItem.removeAttribute('ng-repeat');
                        const replacementSingleItemExpression = itemCollectionExpression + "[" + i +"]";
                        newItem.innerHTML = replaceWordExceptAfterDotInExpr( newItem.innerHTML, singleItemExpression, replacementSingleItemExpression);
                        Array.from(newItem.children).forEach((c) => {
                            Array.from(c.attributes).forEach(function(a) {                                
                                // console.log("replacing '" + a.value + "' with '" + newValue + "'");
                                a.value = replaceWordExceptAfterDot(a.value, singleItemExpression, replacementSingleItemExpression);
                            })
                        });
                        element.parentNode.appendChild(newItem);
                    });
                    element.parentNode.removeChild(element);
                }
            });
        }

        function compileUibCollapse() {
            const elements = document.querySelectorAll('[uib-collapse]');
            elements.forEach(collapsibleElement => {
                const condition = collapsibleElement.getAttribute('uib-collapse');
                if (condition) {
                    const isVisible = evaluateCondition(condition);
                    if (!isVisible) {
                        // collapsibleElement.style.maxHeight = 0;
                        collapsibleElement.style.display = 'none';
                    } else {
                        // collapsibleElement.style.maxHeight = '1000px';
                        collapsibleElement.style.display = ''; 
                    }
                }
            });
        }
    
        function compileNgId() {
            // My own idea. Gives elements an id based on ng-id directive
            const elements = document.querySelectorAll('[ng-id]');
            elements.forEach(element => {
                const expr = element.getAttribute('ng-id');
                console.log("ng-id eval of '" + expr + "'");
                if (expr) {
                    element.setAttribute("id", evaluateExpression(expr));
                }
            });
        }
        
        function compileNgDisabled() {
            const elements = document.querySelectorAll('[ng-disabled]');
            elements.forEach(element => {
                const condition = element.getAttribute('ng-disabled');
                if (condition) {
                    const isDisabled = evaluateCondition(condition);
                    if (!isDisabled) {
                        element.disabled = false;
                    } else {
                        element.disabled = true;
                    }
                }
            });
        }

        function compileTranslations()
        {
            const elements = document.querySelectorAll('[data-translate]');
            elements.forEach(element => {
                const condition = element.getAttribute('data-translate');
                let translation = evalTranslation(element);
                if(element.innerHTML != translation)
                {
                    // console.log("new translation from '" + element.innerHTML + "' to '" + translation + "'");
                }
                element.innerHTML = translation;
            });        
        }
        
        function compileNgShow() {
            const elements = document.querySelectorAll('[ng-show]');
            elements.forEach(element => {
                const condition = element.getAttribute('ng-show');
                if (condition) {
                    const isVisible = evaluateCondition(condition);
                    if (!isVisible) {
                        element.style.display = 'none';
                    } else {
                        element.style.display = ''; // Restore default display
                    }
                }
            });
        }

        function compileNgIf() {
            const elements = document.querySelectorAll('[ng-if]');
            elements.forEach(element => {
                const condition = element.getAttribute('ng-if');
                // element.removeAttribute('ng-if');
                if (condition) {
                    const isVisible = evaluateCondition(condition);
                    if (!isVisible) {
                        element.parentNode.removeChild(element);
                    }
                    // if (!isVisible) {
                    //     element.style.display = 'none';
                    // } else {
                    //     element.style.display = ''; // Restore default display
                    // }
                }
            });
        }

        function replaceWordExceptAfterDotInExpr(inputString, wordA, wordB)
        {
            const strCopy = inputString.split("{{");
            if(strCopy.length < 2)
            {
                return inputString;
            }

            inputString = strCopy.map((s) => {
                let parts = s.split("}}"); 
                if(parts.length == 1)
                    return parts[0]; /*There was a {{ at the beginning of the line*/
                try
                {
                    console.log("Will replace '" + wordA + "' with '" + wordB + "' in '" + parts[0] + "'" );
                    const newValue = replaceWordExceptAfterDot(parts[0], wordA, wordB) + parts[1]; 
                    console.log("returning " + newValue);
                    return newValue;
                }
                catch(e)
                {
                    console.error(e);
                    return s;
                }
            }).join("");

            console.log("string after replace: '" + inputString + "'");
            return inputString;
        }

        function evaluateCondition(condition) {
            try
            {
                return !!eval(condition);
            }
            catch(e)
            {
                console.warn("Error at eval condition:" + condition);
                throw(e);
            }
        }

        function evaluateExpression(expression) {
            // console.log("eval expression:" + expression);
            try
            {
                return eval(expression);
            }
            catch(e)
            {
                console.warn("Error at eval expression: " + expression);
                throw(e);
            }
        }
        
        function populateConfiguration(root, parentGuid = null, level = 1)
        {
            let html = "";
            containers.forEach(function(c, index){
                console.log("populating for container: " + c.name);
                if(c.parentContainer === parentGuid) {
                    const template = document.createElement('template');
                    template.innerHTML = getContentsFromFile('static/elements/container.html').response;
                    // console.log(template.innerHTML);
                    const result = template.content.children;
                    // console.log(result);
                    // Then return either an HTMLElement or HTMLCollection,
                    // based on whether the input HTML had one or more roots.
                    if (result.length === 1)
                    {
                        let e = processElement(
                            {showLabel: showLabel, c: c, level: level, filter: filter},
                            result[0]);
                        if(e != null)
                        {
                            e.id = c.guid;
                            if(parentGuid == null)
                            {
                                e.className = "house-container";
                            }
                            console.log("Adding element ", e, " to root ", root);
                            root.append(e);
                            populateConfiguration(e, c.guid, level + 1);
                        }
                    }
                    // else
                    // {
                    //     root.append(result);
                    //     for(let i = 0 ; i < result.length ; i++)
                    //     {
                    //         populateConfiguration(result[i], c.guid);
                    //     }
                    // }                    
                }
            });
        }

        function evaluateAndCheckPrimitive(code) 
        {
            // console.log("evaluateAndCheckPrimitive expr [" + code + "], with ", context);
            let response = {};
            try
            {
                response['result'] = eval(code);
                const type = typeof response['result'];
                response['error'] = false;
                response['type'] = type;
                response['isPrimitive'] = type !== 'object';
            }
            catch(e)
            {
                response['error'] = true;
            }
            return response;
            // if (type === 'object') {
            //     // if (result === null) {
            //     //     return 'null';
            //     // } else if (Array.isArray(result)) {
            //     //     return 'array';
            //     // } else {
            //     //     return 'object';
            //     // }
            //     return false
            // } 
            
            // // it is a primitive
            // return true;
        }

        function replaceWordExceptAfterDot(inputString, wordA, wordB) {
            // Example usage:
            // const inputString = "This is a wordA. Another wordA here. But not .wordA.";
            // const replacedString = replaceWordExceptAfterDot(inputString, "wordA", "wordB");
            // console.log(replacedString);
            
            // \b is a word boundary to ensure that the word is matched as a whole word.
            // (?<!\.) is a negative lookbehind assertion that ensures the word is not preceded by a dot.
            // g flag is used to perform a global search (i.e., replace all occurrences).
            const regex = new RegExp(`(?<!\\.)\\b$${wordA}\\b`, 'g');
            return inputString.replace(regex, wordB);
        }

        function evalValues(element)
        {
            if(element.innerHTML.length == 0)
            {
                return;
            }

            const strCopy = element.innerHTML.split("{{");
            if(strCopy.length < 2)
            {
                return;
            }

            // console.log("Evaluating innerHTML: ", strCopy);
            element.innerHTML = strCopy.map((s) => {
                let parts = s.split("}}"); 
                if(parts.length == 1)
                    return parts[0]; //There was a {{ at the beginning of the line

                const expr = parts[0];
                try
                {
                    // console.log("Will eval " + expr );
                    let evalExpr = eval(expr) + parts[1];
                    // console.log("evaluation = " + evalExpr);
                    return eval(expr) + parts[1]; 
                }
                catch(e)
                {
                    console.warn("Error in evalValues for expr: '" + expr + "' of element: ", element);
                    console.error(e);
                    return s;
                }
            }).join("");
        }

        function evalSingleBraceValues(text)
        {
            if(text.length == 0)
            {
                return;
            }

            // Split the text using "{" and "}" as delimiters
            var parts = text.split(/({.*?})/);

            // Iterate through the parts
            for (var i = 0; i < parts.length; i++) {
                // Check if the part is enclosed in curly braces
                if (parts[i].startsWith("{") && parts[i].endsWith("}")) {
                    // Remove the braces and evaluate the expression
                    var evaluated = eval(parts[i].substring(1, parts[i].length - 1));
                    // Replace the evaluated expression in the original array
                    parts[i] = evaluated;
                }
            }

            // Join the parts back together to form the modified text
            return parts.join("");
        }

        function evalTranslation(element)
        {
            let dtr = element.getAttribute("data-translate");
            if(dtr == null)
            {
                return;
            }

            let evaledBraces = evalSingleBraceValues(dtr);
            // console.log("evaledBraces: " + evaledBraces);
            let parts = evaledBraces.split(".");
            let tr = JSON.parse(getContentsFromFile('static/i18n/' + language + '/' + parts[0] + '.json').response);
            // console.log(tr);
            // console.log("will get translation by eval tr. +'" + dtr +"'");
            return eval("tr." + evaledBraces);
        }

        function getContentsFromFile(filename)
        {
            // console.log("Getting contents of " + filename);
            let result = {response:  "", found: false};
            if (filename) {
                let cachedTemplate = null;
                // ahat: for some unknown reason deviceHtmlTemplateCache.filter(c => c.filenmame === filename)) does not work here, it returns nothing
                for(let i = 0 ; i < deviceHtmlTemplateCache.length ; i++)
                {
                    if(deviceHtmlTemplateCache[i].filename == filename)
                    {
                        cachedTemplate = deviceHtmlTemplateCache[i];
                        // console.log("Found match but deviceHtmlTemplateCache.filter says: ", deviceHtmlTemplateCache.filter(c => c.filenmame === filename))
                        break;
                    }
                }
                
                if(cachedTemplate != null )
                {
                    // console.log("Found cache of '" + filename + ": ", cachedTemplate);
                    result.response = cachedTemplate.text;
                    result.found = true;
                    return result;
                }

                xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if (this.readyState == 4) {
                        if (this.status == 200) 
                        {
                            result.response = this.responseText;
                            result.found = true;
                            deviceHtmlTemplateCache.push({filename: filename, text: this.responseText });
                        }
                        if (this.status == 404) 
                        {
                            console.log("Returning File not found.");
                            result.response = "File not found.";
                            result.found = false;
                        }
                    }
                }
                xhttp.open("GET", filename, false); //synchronous call
                xhttp.send();
                return result;
            }
            return "No file specified."
        }

        function generateContainerItemTree(containersList, parentId) {
                let containers = [];
                containersList.forEach(function(c) {
                    if (c.parentContainer === parentId) {
                        let container = createGuiContainer(c)
                        containers.push(container);                       
                    }
                });
                return containers;
            }

        function createGuiContainer(containerListElement)
        {
            return {
                guid: containerListElement.guid,
                parentContainer: containerListElement.parentContainer,
                name: containerListElement.containerName,
                containers: generateContainerItemTree(containersList, containerListElement.guid),
                items: items.filter(function(item){
                            return item.itemContainer == containerListElement.guid;
                        }),
                gui : {
                    collapsed: true,
                    allChildrenExpanded: false,
                    showMqttTopics: false,
                    filter: {
                        DOOR: true,
                        WINDOW: true,
                        LIGHT: true,
                        CLIMATE: true,
                        COVER: true,
                        ALARM: true,
                        CAMERA: true,
                        MOTION: true,
                        TANK: true,
                        SWITCH: true,
                        WATER_PUMP: true
                    }
                },
                expandAllChildren: function( expand ) { this.gui.collapsed = expand; for( let c = 0 ; c < this.containers.length ; c++ ) { this.containers[c].expandAllChildren( expand ); } }
            };
        }

        function addDeviceToItem( item )
        {
            switch( item.type )
            {
                case 'ALARM':
                    item.device = new Alarm( item.publish, item.subscribe, new State(["main"]) );
                    break;
                case 'NET':
                    item.device = new Net( item.publish, new State(["main"]) );
                    break;
                case 'DOOR1':
                    item.device = new Door1( item.publish, new State(["main"]) );
                    break;
                case 'DOOR2R':                
                    item.device = new Door2R( item.publish, new State(["left", "right", "recline"]) );
                    break;
                case 'IPCAMERA':
                    item.device = new IPCamera( item.url );
                    break;
                case 'IPCAMERAPANTILT':
                    item.device = new IPCameraPanTilt( item.baseUrl, item.videostream, item.right, item.left, item.up, item.down, item.stop );
                    break;
                case 'LIGHT1':
                    item.device = new Light1( item.publish, item.subscribe, new State(["state"]) );
                    break;
                case 'LIGHT2':
                    item.device = new Light2( item.publish, item.subscribe, new State(["left", "right"]) );
                    break;
                case 'MOTIONSENSOR':
                    item.device = new MotionSensor( item.publish, new State(["main"]) );
                    break;
                case 'MOTIONCAMERA':
                    item.device = new MotionCamera( item.publish, item.subscribe, item.cameraId, item.videostream, 'UNAVAILABLE', 'NO_MOTION' );
                    break;
                case 'MOTIONCAMERAPANTILT':
                    item.device = new MotionCameraPanTilt( item.publish, item.subscribe, item.cameraId, item.videostream, 'UNAVAILABLE', 'NO_MOTION' );
                    break;
                case 'ROLLER1':
                    item.device = new Roller1( item.publish, new State(["main"]) );
                    break;
                case 'ROLLER1_AUTO':
                    item.device = new Roller1_Auto( item.publish, item.subscribe, new State(["main", "percent"]) );
                    break;
                case 'TEMPERATURE_HUMIDITY':
                    item.device = new TemperatureHumidity( item.publish, new State(["main", "temperature", "humidity"]) );
                    break;
                case 'WINDOW1':
                    item.device = new Window1( item.publish, new State(["main"]));
                    break;
                case 'WINDOW1R':
                    item.device = new Window1R( item.publish, new State(["main", "recline"]) );
                    break;
                case 'WINDOW2R':
                    item.device = new Window2R( item.publish, new State(["left", "right", "recline"]) );
                    break;
                case 'MODEM':
                    item.device = new Modem( item.publish, item.subscribe, {} );
                    break;
                case 'WATERTANK':
                    item.device = new Watertank( item.publish, item.subscribe, item.filterById, item.idFilterValue, {} );
                    break;
                case 'SWITCH':
                    item.device = new Switch( item.publish, item.subscribe, new State(["powered", "active", "enabled", "closed", "overriden", "enable", "override"]) );
                    break;
                case 'WATER_PUMP':
                    item.device = new WaterPump( item.publish, item.subscribe, new State(["on"]) );
                    break;
            }
        }
       
        function findContainer(container, containerGuid) {
            if(container.guid === containerGuid)
            {
                return container;
            }

            if(container.containers == null)
            {
                return null;
            }
            for(let i = 0 ; i < container.containers.length ; i++ )
            {
                let foundContainer = findContainer(container.containers[i], containerGuid);
                if(foundContainer != null)
                {
                    return foundContainer;
                }
            }
            return null;
        }
    </script>
</head>
<body>
    <div id="itemStateChangeModal" class="itemStateChangeModalDialog">
        <div class="itemStateChangeModalDialog-content">
          <span class="close" onclick="closeItemStateChangeModal()">&times;</span>
          <p class="itemStateChangeModalDialog-title">Manual state change</p>
          <p id="modalMessage">Manually change the state of <span id="itemNamePlaceholderInModalDialog">item</span></p>
          <div class="itemStateChangeModalDialog-buttons" id="itemStateChangeModalButtons">
            <!-- Buttons will be added here dynamically -->
          </div>
          <button class="itemStateChangeModalDialog-button cancel" onclick="closeItemStateChangeModal()">Cancel</button>
        </div>
      </div>
      <script>
        function manualStateChange(item, pairs) {
          let modal = document.getElementById("itemStateChangeModal");
          let modalButtons = document.getElementById("itemStateChangeModalButtons");
          let itemNamePlaceholder = document.getElementById("itemNamePlaceholderInModalDialog");
        
          // Set item name in placeholder
          itemNamePlaceholder.textContent = item.name;
        
          // Clear previous buttons
          modalButtons.innerHTML = "";
        
          // Add buttons based on pairs
          pairs.forEach(pair => {
            let button = document.createElement("button");
            button.textContent = pair[0];
            button.classList.add("itemStateChangeModalDialog-button");
            button.onclick = function() {
              console.log(pair[1]);
              item.device.sendStatus(pair[1]);
              closeItemStateChangeModal();
            };
            modalButtons.appendChild(button);
          });
        
          // Display itemStateChangeModalDialog
          modal.style.display = "block";
        }
        
        function closeItemStateChangeModal() {
          var modal = document.getElementById("itemStateChangeModal");
          modal.style.display = "none";
        }
        
        // Example usage
        var item = { name: "Example Item" };
        var pairs = [
          ["Button 1", "Action 1"],
          ["Button 2", "Action 2"],
          ["Button 3", "Action 3"]
        ];
        
        //openModal(item, pairs);
        </script>
    
    <div id="content">
        <div class="servers">
            <div ng-repeat="s in mqttServers">
                <server server="s"></server>
            </div>
        </div>
        <div ng-repeat="o in containers">
            <container container='o' level="1" show-label="true" expandAllChildren="true" is-collapsed-house="false" filter="filter" show-mqtt-topics="showMqttTopics"/>
        </div>
    </div>
</body>
</html>