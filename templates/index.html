$def with (mqtt_servers, containers, domains, item_types, items)
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>eHome</title>

    <link rel="stylesheet" href="/static/css/bootstrap.css">
    <link rel="stylesheet" href="/static/css/bootstrap-toggle.min.css">
    <link rel="stylesheet" href="/static/css/materialdesignicons.min.css">

    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="stylesheet" href="/static/css/old.css">
    <script src="/static/scripts/paho-mqtt.min.js"></script>

    <script src="/static/scripts/devices/mqtt_device.js"></script>
    <script src="/static/scripts/devices/alarm.js"></script>
    <script src="/static/scripts/devices/door1.js"></script>
    <script src="/static/scripts/devices/door2r.js"></script>
    <script src="/static/scripts/devices/ipcamera.js"></script>
    <script src="/static/scripts/devices/ipcameraPanTilt.js"></script>
    <script src="/static/scripts/devices/light1.js"></script>
    <script src="/static/scripts/devices/light2.js"></script>
    <!-- <script src="/static/scripts/devices/modem.js"></script> -->
    <script src="/static/scripts/devices/motionCamera.js"></script>
    <script src="/static/scripts/devices/motionCameraPanTilt.js"></script>
    <script src="/static/scripts/devices/net.js"></script>
    <script src="/static/scripts/devices/roller1.js"></script>
    <script src="/static/scripts/devices/roller1_auto.js"></script>
    <script src="/static/scripts/devices/server-connection.js"></script>
    <script src="/static/scripts/devices/temperature_humidity.js"></script>
    <script src="/static/scripts/devices/window1.js"></script>
    <script src="/static/scripts/devices/window1r.js"></script>
    <script src="/static/scripts/devices/window2r.js"></script>

    <script>
        // mqttServer data
        var mqttServers = [
            $for server in mqtt_servers:
                { 
                    id: $(loop.index0), 
                    address: "$server['address']", 
                    port: "$server['port']", 
                    ws_port: "$server['ws_port']", 
                    username: "$(server['username'] if server['username'] is not None else "null" )", 
                    password: "$(server['password'] if server['password'] is not None else "null" )",
                    subscribptions: {},
                    connection: { type: 'NOT_CONNECTED' },
                    lastUpdate: null,
                    connect: function(){
                        this.updateConnecting();
                        try
                        {
                            // first attempt tot disconnect
                            console.log("client: ", client);
                            for (const [key, value] of Object.entries(client)) 
                            {
                                // ATTENTION: only attempt a disconnect if the client is connected or else we crash
                                if(value != null && value != undefined && key == this.key() && this.connection.type == 'CONNECTED')
                                {
                                    console.log(`Disconnecting from mqtt server: $${key}, client: $${value}`);
                                    try
                                    {
                                        value.disconnect();
                                    }
                                    catch(e)
                                    {
                                        console.error("Disconnect failed");
                                        console.error(e);
                                    }
                                    break;
                                }
                            }
                            this.connection.type = 'CONNECTING';
                            // ATTENTION: this web paho client must connect to the mqtt server's ws_port, not the regular port
                            client[this.key()] = new Paho.Client(this.address, Number(this.ws_port), "clientId" + Math.random());
                            client[this.key()].onConnectionLost = onConnectionLost;
                            client[this.key()].onMessageArrived = onMessageArrived;
                            client[this.key()].connect({ 
                                timeout: 5,
                                reconnect: false,
                                onFailure: onFailure,
                                onSuccess: onConnect, 
                                invocationContext: this // pass the server as argument to the callback success function
                            });
                        }
                        catch(e)
                        {
                            console.warn("Connection to " + this.key() + " failed.");
                            console.error(e);
                        }
                    },
                    key: function(){ return this.address + ":" + this.ws_port;},
                    updateConnected: function(){
                        this.connection.type = 'CONNECTED';
                        this.lastUpdate = new Date();
                        let id  = 'server_lastUpdate_' + this.key();
                        let element = document.getElementById(id);
                        if(element != null)
                        {
                            element.textContent = this.lastUpdate.toLocaleString();
                            compileNgShow();
                        }
                    },
                    updateDisconnected: function(){
                        this.connection.type = 'NOT_CONNECTED';
                        this.lastUpdate = new Date();
                        let id  = 'server_lastUpdate_' + this.key();
                        let element = document.getElementById(id);
                        if(element != null)
                        {
                            element.textContent = this.lastUpdate.toLocaleString();
                            compileNgShow();
                        }
                    },
                    updateConnecting: function(){
                        this.connection.type = 'CONNECTING';
                        this.lastUpdate = new Date();
                        let id  = 'server_lastUpdate_' + this.key();
                        let element = document.getElementById(id);
                        if(element != null)
                        {
                            element.textContent = this.lastUpdate.toLocaleString();
                            compileNgShow();
                        }
                    }
                },
        ];

        var containersList = [
            $for container in containers:
                { id: $(loop.index-1), containerName: "$container['containerName']", parentContainer: "$(container['parentContainer'] if container['parentContainer'] is not None else "null" )", guid: "$container['guid']" },
        ];
        // replace string null with actual null
        containersList.forEach(function(c){
            if( c.parentContainer == "null" )
            {
                c.parentContainer = null;
            }
        })

        var item_types = [
            $for item_type in item_types:
                { id: "$item_type['id']", description:"$item_type['description']" },
        ];
                
        var items = [
            $for item in items:
                { 
                    id: $(loop.index0), 
                    name: "$item['itemName']", 
                    itemMqttServer: $item['itemMqttServer'], 
                    itemContainer: "$item['itemContainer']", 
                    type: "$item['itemType']", 
                    publish: "$item['publish']",
                    subscribe: "$item['subscribe']",
                    state: "UNKNOWN",
                    showDeviceCommands: false,
                    // for cameras
                    url: null,
                    baseUrl: null,
                    videostream: null,
                    right: null,
                    left: null,
                    up: null,
                    down: null,
                    stop: null,                    
                    cameraId: null
                },
        ];
        
        var filter = {
                        DOOR: true,
                        WINDOW: true,
                        LIGHT: true,
                        CLIMATE: true,
                        COVER: true,
                        ALARM: true,
                        CAMERA: true,
                        MOTION: true                        
                    };

        var deviceHtmlTemplateCache = [];

        const client = {};

        function connectToMqtt(server) {
            console.log(server);
            server.connect(client);
        }

        function onConnect(connectOptions) {
            let server = connectOptions.invocationContext;
            server.connection.type = 'CONNECTED';
            console.log("Connected to ", server);
            server.updateConnected();

            // console.log("Connected to MQTT server " + connectOptions.invocationContext['address'] + ":" + connectOptions.invocationContext['ws_port']);
            // client[connectOptions.invocationContext['address']+":"+connectOptions.invocationContext['ws_port']].subscribe("test/topic");

            
            items.forEach(i => {
                // create the array of subscribed devices if no device has been subscribed yet
                if(server.subscribptions[i.publish] == null || server.subscribptions[i.publish] == undefined)
                {
                    server.subscribptions[i.publish] = [];
                    console.log("creating subscriptions dictionary entry for topic: " + i.publish);
                }
            
                server.subscribptions[i.publish].push(i.device);  // register the device for this topic
                client[server.key()].subscribe(i.publish);        // subscribe to the device's publish topic
            
                i.device.setPublisher(client[server.key()]); // tell each device that this client is its publisher for sending mqtt messages
            });
        }

        function onConnectionLost(responseObject) {
            if (responseObject.errorCode !== 0) {
                let server = mqttServers.filter(s => s.key() == (this.host + ":" + this.port))[0];
                server.connection.type = 'NOT_CONNECTED';
                console.log("Connection lost:", responseObject.errorMessage, " on server: ", server);
            }
        }

        function onFailure(errorMessage) {
            console.error('Failed to connect to MQTT broker. Error: ' + errorMessage.errorMessage, ", this: ", this);
            let server = this.invocationContext;
            server.updateDisconnected();
        }
 
        var configuration_str = "";
        function onMessageArrived(message) {
            // console.log("this: ", this);
            // console.log("new message: " + message.topic + message.payloadString, message);
            let server = mqttServers.filter(s => s.key() == (this.host + ":" + this.port))[0];
            server.subscribptions[message.topic].forEach(d => d.update(message.topic, message.payloadString));
            server.lastUpdate = new Date();
            let id = "server_lastUpdate_" + server.key()
            document.getElementById(id).textContent = server.lastUpdate.toLocaleString();
            console.log("new content of element id:" + id + ", element: ", element);
            return;

            if(message.payloadString != configuration_str)
            {
                console.log("New configuration.");
                try
                {
                    // in case we are called after a configuration refresh, first disconnect already conencted clients
                    for (const [key, value] of Object.entries(client)) 
                    {
                        if(value != null && value != undefined)
                        {
                            console.log(`Disconnecting from mqtt server: $${key}, client: $${value}`);
                            value.disconnect();
                        }
                    }
                }
                catch(e)
                {
                    console.error(e);
                }

                configuration_str = message.payloadString;
                let configuration = JSON.parse(configuration_str);
                mqttServers = configuration.mqttServers;
                containersList = configuration.containers;
                item_types = configuration.item_types;
                items = configuration.items;                
                initContent();
            }
            else
            {
                console.log("Configuration unchanged.");
            }
            // const ul = document.getElementById("messages");
            // const li = document.createElement("li");
            // li.appendChild(document.createTextNode(message.payloadString));
            // ul.appendChild(li);
        }

        const customElementDirectives = [
            {
                elements: ["server"],
                attributesToContext: [{ attribute: "server", contextProperty: 'server'}]
            },
            {
                elements: ["container"], 
                attributesToContext: [
                    { attribute: "container", contextProperty: 'c'},
                    { attribute: "level", contextProperty: 'level'},
                    { attribute: "show-label", contextProperty: 'showLabel'},
                    { attribute: "expandAllChildren", contextProperty: 'expandAllChildren'},
                    { attribute: "is-collapsed-house", contextProperty: 'isCollapsedHouse'},
                    { attribute: "filter", contextProperty: 'filter'},
                    { attribute: "show-mqtt-topics", contextProperty: 'showMqttTopics'}
                ]
            },
            {
                elements: ["item", "alarm", "door1", "door2r", "window1", "window1r", "window2r", "light1", "light2", "ipcamera", "ipcamera-pan-tilt", "motion-camera", "motion-camera-pan-tilt", "temphum", "net", "roller1", "roller1auto"], 
                attributesToContext: [
                    { attribute: "item", contextProperty: 'i'},
                    { attribute: "filter", contextProperty: 'filter'},
                    { attribute: "is-collapsed-house", contextProperty: 'isCollapsedHouse'},
                    { attribute: "is-collapsed-floor", contextProperty: 'isCollapsedFloor'},
                    { attribute: "is-collapsed-room", contextProperty: 'isCollapsedRoom'},
                    { attribute: "show-mqtt-topics", contextProperty: 'showMqttTopics'}

                ]
            }                
        ];

        var language = 'el';

        // Observe changes in variables and recompile directives accordingly
        var containers = [];
        var hiddenContainers = [];
        
        var proxyContainerRecompileNgClass = false;
        
        // other proxied objects that will trigger recompile of ngClass
        var otherProxies = [];

        window.onload = function () {
            console.log("window.onload");
            initContent();
        };

        function initContent()
        {
            proxyContainerRecompileNgClass = false;
            mqttServers.forEach(connectToMqtt);
            
            items.forEach(i => { addDeviceToItem(i);});
            console.log("items: ", items);

            hiddenContainers = generateContainerItemTree(containersList, null);
            containers = []; // these will be the proxies
            hiddenContainers.forEach(hc => { containers.push(createProxiedContainer(hc)); });

            // populateConfiguration(document.getElementById("content"));      
            // return;

            // containers = containersList;
            // document.getElementById('content').innerHTML=
            // getContentsFromFile('static/elements/container.html').response;
            while(documentContainsNgRepeat() || documentContainsReplaceableCustomElements())
            // for(let i = 0 ; i < 3 ; i++)
            {
                console.log((documentContainsNgRepeat() || documentContainsReplaceableCustomElements()));
                compileNgIf();
                compileNgRepeat();
                compileCustomElements();
            }
            // compileNgInit(); see TODO comment inside compileNgInit()
            compileNgId();
            compileNgShow();
            compileUibCollapse();
            compileNgClass();
            evalValues(null, document.getElementById('content'));
            compileNgClick();
            compileNgDisabled();
            
            // for reacting to changes in the document
            const observer = new MutationObserver(() => {
                // TODO
            });

            observer.observe(document.getElementById("content"), {
                attributes: true,
                childList: true,
                subtree: true
            });

            proxyContainerRecompileNgClass = true;
            // console.log("full text: ", document.getElementById("content").innerHTML);            
        }

        function createProxy(obj) {
            return new Proxy(obj, {
                get(target, property, receiver) {
                    const value = Reflect.get(target, property, receiver);
                    // console.log(`Getting $${property}: `,value);
                    return value;
                },
                set(target, property, value, receiver) {
                    // console.log(`Setting $${property} to `,value);
                    const success = Reflect.set(target, property, value, receiver);
                    if (success) {
                        // console.log("set operaton was successfull, proxyContainerRecompileNgClass: " + proxyContainerRecompileNgClass);
                        if(proxyContainerRecompileNgClass)
                        {
                            compileNgIf();
                            compileUibCollapse();
                            compileNgShow();
                            compileNgClass();
                            compileNgDisabled();
                        }
                    }
                    return success;
                }
            });
        }

        function createProxiedContainer(obj) {
            // Create a proxy for the object itself
            // it is good not just for containers but for any object with other
            // nested objects as properties
            const proxiedObject = createProxy(obj);

            // Create proxies for each property that is an object or an array
            for (const key in proxiedObject) {
                if (typeof proxiedObject[key] === 'object' && proxiedObject[key] !== null) {
                    proxiedObject[key] = createProxiedContainer(proxiedObject[key]);
                }
            }

            return proxiedObject;
        }

        function documentContainsReplaceableCustomElements()
        {
            const ces = document.querySelectorAll(customElementDirectives.map((ced) => {return ced.elements;}).flat().join(", "));
            if(ces.length == 0)
            {
                return false;
            }

            let htmlFilesExist = true;
            ces.forEach((c) => {
                let text = getContentsFromFile('static/elements/' + c.localName + '.html');
                htmlFilesExist = htmlFilesExist && text.found;
            })
            return htmlFilesExist;
        }

        function documentContainsNgRepeat()
        {
            return document.querySelectorAll('[ng-repeat]').length > 0;
        }

        function collectAttributes(node, attributes, textNodes) {
            // Collect attributes from the current element in order to update their values
            // by replacing variables appearing as isolated scope in custom elements
            // console.log("node: ", node, " has " + node.attributes.length + " attribues: ", node.attributes);
            if (node.nodeType === Node.ELEMENT_NODE && node.attributes.length > 0){
                for (let i = 0; i < node.attributes.length; i++) {
                    const attribute = node.attributes[i];
                    if (attribute.name.startsWith('ng-') ||
                        attribute.name === "data-translate" ||
                        attribute.name === "uib-collapse" ||
                        customElementDirectives.map(c => c.attributesToContext.map(a => a.attribute))
                            .flat()
                            .some(a => a.toLowerCase() === attribute.name.toLowerCase() )
                    ) {
                        attributes.push(attribute);
                    }
                }
            }

            // If the node is a text node, collect it
            if (node.nodeType === Node.TEXT_NODE && node.textContent.includes("{{")) {
                textNodes.push(node);                
            }

            // Recursively collect attributes from child nodes
            // console.log("element: ", element, " has " + element.children.length + ": ", element.children);
            if (node.hasChildNodes()) {
                for (let i = 0; i < node.childNodes.length; i++) {
                    collectAttributes(node.childNodes[i], attributes, textNodes);
                }
            }
        }

        function replaceWordAWithWordB(template, wordA, wordB) {
            // Example usage:
            // const template = document.createElement('div');
            // template.innerHTML = `
            //     <div ng-attr1="wordA" ng-attr2="wordA">wordA.wordA</div>
            //     <div>{{expression1 + wordA}}</div>
            //     <div>{{expression2 + wordA}}</div>
            // `;
            // const wordA = "wordA";
            // const wordB = "wordB";
            // replaceWordAWithWordB(template, wordA, wordB);
            // console.log(template.outerHTML);

            const attributes = [];
            const textNodes = [];
            collectAttributes(template, attributes, textNodes);
            // console.log("collected attributes: ", attributes);
            // console.log("collected textNodes: ", textNodes);
            const content = template.innerHTML;

            // console.log("replacing '" + wordA + "' with '" + wordB + "' in all collected attributes");
            // Loop through all attributes
            for (let i = 0; i < attributes.length; i++) {
                const attributeName = attributes[i].name;
                const attributeValue = attributes[i].value;

                // Replace wordA with wordB in attribute values
                // const replacedAttributeValue = attributeValue.replace(new RegExp(`([^.]|^)$${wordA}([^.]|$$)`, 'g'), function(match, before, after) {
                //     return before + wordB + after;
                // });
                const replacedAttributeValue = attributeValue.replace(new RegExp(`(?<!\\.)\\b$${wordA}\\b`, 'g'), wordB);

                // Update the attribute value
                // console.log("updating " + attributeName + ", old value: '" + attributeValue + "', new value: '" + replacedAttributeValue + "'" );
                attributes[i].value = replacedAttributeValue;
            }
            // console.log("template now is: ", template.innerHTML);
            // Replace wordA with wordB in content (within '{{' and '}}')
            textNodes.forEach(t =>{
                t.textContent = t.textContent.replace(new RegExp(`(?<!\\{\\{.*\\.)\\b$${wordA}\\b(?=.*\\}\\})`, 'g'), wordB);
            });
            // console.log("collected attributes after replacement: ", attributes);

            // const replacedContent = template.innerHTML.replace(new RegExp(`(?<!\\.{{.*)\\b$${wordA}\\b(?=.*}}(?!.*}})`, 'g'), wordB);
            
            // const replacedContent = content.replace(new RegExp(`{{(.*?)$${wordA}(.*?)}}`, 'g'), function(match, before, after) {
            //     return `{{$${before}$${wordB}$${after}}}`;
            // });

            // Update the content
            // template.innerHTML = replacedContent;
        }

        function compileCustomElements()
        {
            const elements = document.querySelectorAll(customElementDirectives.map((ced) => {return ced.elements;}).flat().join(", "));
            elements.forEach((element) => {
                // console.log("attributes: ", element.attributes, " of element:", element);                
                let text = getContentsFromFile('static/elements/' + element.localName + '.html');
                if(!text.found)
                {
                    console.log('No html file found for ' + element.localName + ' in static/elements');
                    return true;
                }
                // console.log("text from file: " + text.response);
                let template = document.createElement('template');
                template.innerHTML = text.response;

                customElementDirectives
                .find(cd => {return cd.elements.indexOf(element.localName) > -1;})
                .attributesToContext.forEach(a2c =>{
                    // console.log("template was: " + template.innerHTML);
                    // copy computed values of attributes already stored in context with key = attribute.name
                    // into new (or existing) context keys for use in children of element
                    let oldValue = element.getAttribute(a2c.attribute);
                    let replacementValue = oldValue;
                    if(oldValue != null)
                    {
                        // console.log(a2c.attribute + " old value: " + oldValue);
                        const evaluatedValue = evaluateAndCheckPrimitive(oldValue);
                        if(!evaluatedValue.error && evaluatedValue.isPrimitive)
                        {
                            // console.log("newValue: " + newValue.result );
                            // element.setAttribute(a2c.attribute, newValue.result);
                            replacementValue = "(" + element.getAttribute(a2c.attribute) + ")"
                        }
                    }

                    replaceWordAWithWordB(template.content, a2c.contextProperty, replacementValue);
                    // console.log("template now is: " + template.innerHTML);
                });
               
                element.parentNode.appendChild(template.content.cloneNode(true));
                element.remove();
            });
        }

        function compileNgInit() {
            // TODO: this does not really work. Besides all variables declared in ng-init
            // are device specific flags used to indicate if some device property should be
            // displayed, mainly in camera elements. Move these variables into the device.
            const elements = document.querySelectorAll('[ng-init]');
            elements.forEach(element => {
                const expression = element.getAttribute('ng-init');

                const scope = {}; // Create an object to represent the scope

                // Evaluate the expression in the scope context
                // Here, we use an immediately invoked function expression (IIFE) to create a local scope
                // (function(scope) {
                    // Use eval() to evaluate the expression in the scope context
                    try
                    {
                        // define arrays before assignment
                        const arrays = expression.split(";").map(s => {a = s.split("=")[0].trim(); if(a.indexOf("[") > -1) return a.split("[")[0]; else return null;}).filter(a => a != null && a != undefined).forEach(v => {
                            let defExpr = "" + v + "=[];";
                            defExpr += "otherProxies.push(createProxiedContainer." + v +");";
                            console.log("compileNgInit declares array: '" + defExpr + "'");
                            console.log(eval(defExpr));
                        });

                        console.log("compileNgInit evals init: '" + expression + "'");
                        eval(expression);
                    }
                    catch(e)
                    {
                        console.warn("Error in compileNgInit for eval expr: '" + expression + "'");
                        throw(e);
                    }
                // })(scope);

                // Copy variables from the scope object to the current scope
                for (const key in scope) {
                    if (scope.hasOwnProperty(key)) {
                        window[key] = scope[key];
                    }
                }
            });
        }

        function compileNgClick() {
            const elements = document.querySelectorAll('[ng-click]');
            elements.forEach(element => {
                const clickHandler = element.getAttribute('ng-click');
                if (!!clickHandler) {
                    // console.log("adding click eventListenr '" + clickHandler + "' to element: ", element);
                    element.addEventListener('click', function() {
                        console.log("eval clickHandler: ", clickHandler);
                        console.log(eval(clickHandler));
                    });
                }
            });
        }

        function compileNgClass() {
            const elements = document.querySelectorAll('[ng-class]');
            elements.forEach(element => {
                // const ngClass = element.getAttribute('ng-class').split("'").join("\"").split(":").map(s => s.trim()).join(": \"").split(",").map(s => s.trim()).join("\", ").split("}").map(s => s.trim()).join("\" }");
                const ngClass = "{" + element.getAttribute('ng-class').slice(1,-1).split(",").map(s => s.split(":").map(s => s.trim())).map(s => {return s[0].split("'").join("\"") + " : \"" + s[1] +"\"";}).join(", ") + "}";
                try
                {
                    // console.log("ngClass '" + ngClass + "' for element: ", element);
                    const classesObject = JSON.parse(ngClass);
                    Object.keys(classesObject).forEach(className => {
                        const condition = eval(classesObject[className]);
                        className.split(" ").forEach(cn => {
                        if (condition) {
                                element.classList.add(cn);
                            } else {
                                element.classList.remove(cn);
                            }
                        });
                    });
                }
                catch(e)
                {
                    console.warn("Error in compileNgClass for ngClass='" + ngClass + "'");
                    throw(e);
                }
            });
        }

        // Compile ng-repeat directive
        function compileNgRepeat() {
            const elements = document.querySelectorAll('[ng-repeat]');
            elements.forEach(element => {
                const ngRepeat = element.getAttribute('ng-repeat');
                if (ngRepeat) {
                    const parts = ngRepeat.split(' in ');
                    const singleItemExpression = parts[0].trim();
                    const itemCollectionExpression = parts[1].trim();
                    // console.log("singleItemExpression: '" + singleItemExpression + "', itemCollectionExpression: '" + itemCollectionExpression + "'");
                    const items = evaluateExpression(itemCollectionExpression);
                    items.forEach((item,i) => {
                        const newItem = element.cloneNode(true);
                        newItem.removeAttribute('ng-repeat');
                        const replacementSingleItemExpression = itemCollectionExpression + "[" + i +"]";
                        newItem.innerHTML = replaceWordExceptAfterDotInExpr( newItem.innerHTML, singleItemExpression, replacementSingleItemExpression);
                        Array.from(newItem.children).forEach((c) => {
                            Array.from(c.attributes).forEach(function(a) {                                
                                // console.log("replacing '" + a.value + "' with '" + newValue + "'");
                                a.value = replaceWordExceptAfterDot(a.value, singleItemExpression, replacementSingleItemExpression);
                            })
                        });
                        element.parentNode.appendChild(newItem);
                    });
                    element.parentNode.removeChild(element);
                }
            });
        }

        function compileUibCollapse() {
            const elements = document.querySelectorAll('[uib-collapse]');
            elements.forEach(collapsibleElement => {
                const condition = collapsibleElement.getAttribute('uib-collapse');
                if (condition) {
                    const isVisible = evaluateCondition(condition);
                    if (!isVisible) {
                        // collapsibleElement.style.maxHeight = 0;
                        collapsibleElement.style.display = 'none';
                    } else {
                        // collapsibleElement.style.maxHeight = '1000px';
                        collapsibleElement.style.display = ''; 
                    }
                }
            });
        }
    
        function compileNgId() {
            // My own idea. Gives elements an id based on ng-id directive
            const elements = document.querySelectorAll('[ng-id]');
            elements.forEach(element => {
                const expr = element.getAttribute('ng-id');
                console.log("ng-id eval of '" + expr + "'");
                if (expr) {
                    element.setAttribute("id", evaluateExpression(expr));
                }
            });
        }
        
        function compileNgDisabled() {
            const elements = document.querySelectorAll('[ng-disabled]');
            elements.forEach(element => {
                const condition = element.getAttribute('ng-disabled');
                if (condition) {
                    const isDisabled = evaluateCondition(condition);
                    if (!isDisabled) {
                        element.disabled = false;
                    } else {
                        element.disabled = true;
                    }
                }
            });
        }
        
        function compileNgShow() {
            const elements = document.querySelectorAll('[ng-show]');
            elements.forEach(element => {
                const condition = element.getAttribute('ng-show');
                if (condition) {
                    const isVisible = evaluateCondition(condition);
                    if (!isVisible) {
                        element.style.display = 'none';
                    } else {
                        element.style.display = ''; // Restore default display
                    }
                }
            });
        }

        function compileNgIf() {
            const elements = document.querySelectorAll('[ng-if]');
            elements.forEach(element => {
                const condition = element.getAttribute('ng-if');
                // element.removeAttribute('ng-if');
                if (condition) {
                    const isVisible = evaluateCondition(condition);
                    if (!isVisible) {
                        element.parentNode.removeChild(element);
                    }
                    // if (!isVisible) {
                    //     element.style.display = 'none';
                    // } else {
                    //     element.style.display = ''; // Restore default display
                    // }
                }
            });
        }

        function replaceWordExceptAfterDotInExpr(inputString, wordA, wordB)
        {
            const strCopy = inputString.split("{{");
            if(strCopy.length < 2)
            {
                return inputString;
            }

            inputString = strCopy.map((s) => {
                let parts = s.split("}}"); 
                if(parts.length == 1)
                    return parts[0]; /*There was a {{ at the beginning of the line*/
                try
                {
                    console.log("Will replace '" + wordA + "' with '" + wordB + "' in '" + parts[0] + "'" );
                    const newValue = replaceWordExceptAfterDot(parts[0], wordA, wordB) + parts[1]; 
                    console.log("returning " + newValue);
                    return newValue;
                }
                catch(e)
                {
                    console.error(e);
                    return s;
                }
            }).join("");

            console.log("string after replace: '" + inputString + "'");
            return inputString;
        }

        // Evaluate condition expression
        function evaluateCondition(condition) {
            try
            {
                return !!eval(condition);
            }
            catch(e)
            {
                console.warn("Error at eval condition:" + condition);
                throw(e);
            }
        }

        // Evaluate expression
        function evaluateExpression(expression) {
            // console.log("eval expression:" + expression);
            try
            {
                return eval(expression);
            }
            catch(e)
            {
                console.warn("Error at eval expression:" + expression);
                throw(e);
            }
        }
        
        function populateConfiguration(root, parentGuid = null, level = 1)
        {
            let html = "";
            containers.forEach(function(c, index){
                console.log("populating for container: " + c.name);
                if(c.parentContainer === parentGuid) {
                    const template = document.createElement('template');
                    template.innerHTML = getContentsFromFile('static/elements/container.html').response;
                    // console.log(template.innerHTML);
                    const result = template.content.children;
                    // console.log(result);
                    // Then return either an HTMLElement or HTMLCollection,
                    // based on whether the input HTML had one or more roots.
                    if (result.length === 1)
                    {
                        let e = processElement(
                            {showLabel: showLabel, c: c, level: level, filter: filter},
                            result[0]);
                        if(e != null)
                        {
                            e.id = c.guid;
                            if(parentGuid == null)
                            {
                                e.className = "house-container";
                            }
                            console.log("Adding element ", e, " to root ", root);
                            root.append(e);
                            populateConfiguration(e, c.guid, level + 1);
                        }
                    }
                    // else
                    // {
                    //     root.append(result);
                    //     for(let i = 0 ; i < result.length ; i++)
                    //     {
                    //         populateConfiguration(result[i], c.guid);
                    //     }
                    // }                    
                }
            });
        }

        function evaluateAndCheckPrimitive(code) 
        {
            // console.log("evaluateAndCheckPrimitive expr [" + code + "], with ", context);
            let response = {};
            try
            {
                response['result'] = eval(code);
                const type = typeof response['result'];
                response['error'] = false;
                response['type'] = type;
                response['isPrimitive'] = type !== 'object';
            }
            catch(e)
            {
                response['error'] = true;
            }
            return response;
            // if (type === 'object') {
            //     // if (result === null) {
            //     //     return 'null';
            //     // } else if (Array.isArray(result)) {
            //     //     return 'array';
            //     // } else {
            //     //     return 'object';
            //     // }
            //     return false
            // } 
            
            // // it is a primitive
            // return true;
        }

        // evalRepeat will return false if the element was removed in order
        // to indicate that its children should not be processed any further
        function evalRepeat(context, element)
        {
            let rep = element.getAttribute('ng-repeat');
            if(rep == null)
            {
                return true;
            }
            console.log("evalRepeat for ", element)
            let parts = rep.trim().split(" in ");
            console.log("parts:", parts);
            let newContext = {...context};
            let length = eval(addContextToExpression(context, parts[1]) + ".length");
            console.log("length: " + addContextToExpression(context, parts[1]) + ".length: " + length);
            if(length == 0)
            {
                element.remove();
                console.log("Removed ", element, " and returnig from evalRepeat");
                return false;
            }

            element.removeAttribute('ng-repeat');
            for(let i = 0 ; i < length ; i++)
            {
                newContext[parts[0]] = eval(addContextToExpression(context, parts[1]) + "[" + i + "]");
                console.log("evalRepeat newContext: ", newContext);
                let newElement = element;
                if(i > 0)
                {
                    newElement = element.cloneNode(true);
                    element.parentNode.appendChild(newElement);
                }
                console.log("newElement: ", newElement);
                console.log("newElement.children: ", newElement.children);
                Array.from(newElement.children).forEach(c => {
                    Array.from(c.attributes).forEach(a => {
                        // replace any occurences of ng-repeat value with the ng-repeat-expr[i]
                        a.value = replaceWordExceptAfterDot(a.value, parts[0], parts[1] + "[" + i + "]");
                        // if(a.value == parts[0])
                        // {
                        //     a.value = parts[1] + "[" + i + "]";
                        // }
                    });
                });
                console.log("Will now process newElements from evalRepeat");
                processElement(newContext, newElement);
            }
            // element.parentNode.removeChild(element);
            return true;
        }

        function replaceWordExceptAfterDot(inputString, wordA, wordB) {
            // Example usage:
            // const inputString = "This is a wordA. Another wordA here. But not .wordA.";
            // const replacedString = replaceWordExceptAfterDot(inputString, "wordA", "wordB");
            // console.log(replacedString);
            
            // \b is a word boundary to ensure that the word is matched as a whole word.
            // (?<!\.) is a negative lookbehind assertion that ensures the word is not preceded by a dot.
            // g flag is used to perform a global search (i.e., replace all occurrences).
            const regex = new RegExp(`(?<!\\.)\\b$${wordA}\\b`, 'g');
            return inputString.replace(regex, wordB);
        }

        function evalTranslation(element)
        {
            let dtr = element.getAttribute("data-translate");
            if(dtr == null)
            {
                return;
            }

            let parts = dtr.split(".");
            let tr = JSON.parse(getContentsFromFile('static/i18n/' + language + '/' + parts[0] + '.json').response);
            // console.log(tr);
            element.innerHTML = eval("tr." + dtr);
        }

        function evalClass(context, element)
        {
            let cls = element.getAttribute("ng-class");
            if(cls)
            {
                cls = cls.replace(/^(\{+)/, '').replace(/(\}+)$$/, '').split(",").map((c) => c.trim());
                for(var i = 0 ; i < cls.length ; i++)
                {
                    let parts = cls[i].split(':').map((s) => s.trim());
                    const expr = addContextToExpression(context, parts[1]);
                    try
                    {
                        // console.log("Eval: " + expr + ", with context: ", context);
                        if(eval(expr))
                        {
                            element.className = element.className + " " + parts[0].replace(/^(['"]+)/, '').replace(/(['"]+)$$/, '').trim()
                        }
                    }
                    catch(e)
                    {
                        console.error(e);
                    }
                }
            }
        }

        function evalValues(context, element)
        {
            if(element.innerHTML.length == 0)
            {
                return;
            }

            const strCopy = element.innerHTML.split("{{");
            if(strCopy.length < 2)
            {
                return;
            }

            // console.log("Evaluating innerHTML: ", strCopy, " with context: ", context);
            element.innerHTML = strCopy.map((s) => {
                let parts = s.split("}}"); 
                if(parts.length == 1)
                    return parts[0]; /*There was a {{ at the beginning of the line*/

                const expr = parts[0];
                if(context != null) 
                {
                    expr = addContextToExpression(context, parts[0]);
                }
                try
                {
                    // console.log("Will eval " + expr );
                    let evalExpr = eval(expr) + parts[1];
                    // console.log("evaluation = " + evalExpr);
                    return eval(expr) + parts[1]; 
                }
                catch(e)
                {
                    console.warn("Error in evalValues for expr: '" + expr + "' of element: ", element);
                    console.error(e);
                    return s;
                }
            }).join("");
        }

        function addContextToExpression(context, expr)
        {
            const prefix = "context.";
            const words = Object.keys(context);
            return addPrefixToWordsInExpression(prefix, words, expr)
        }

        function addPrefixToWordsInExpression(prefix, words, expr)
        {
            const regex = new RegExp(`(?<!\\.)\\b($${words.join('|')})\\b`, 'g');
            return expr.replace(regex, `$${prefix}$$1`);
        }

        function evalIf(context, element)
        {
            let _if = element.getAttribute("ng-if");
            if(_if)
            {
                try
                {
                    const expr = addContextToExpression(context, _if);
                    // console.log("Eval: " + expr + ", with context: ", context);
                    // console.log(eval(expr));
                    if(!eval(expr))
                    {
                        // console.log("Processing returns false");
                        element.style.visibility = "hidden";
                        // element.replaceWith(document.createElement("span"));
                        return false;
                    }
                }
                catch(e)
                {
                    console.log("Eval of '" + _if + "' of element: ", element, " with context: ", context );
                    console.error("generated error; ", e);
                }
            }
            return true;
        }

        function evalAttributesByContext(context, element)
        {
            if(!('attributes' in element))
            {
                return;
            }
            // console.log(element.attributes);
            // console.log("Before evalAttributesByContext of element ", element, " context: ", context);
            // evaluate attribute values if the result is a primitive e.g. int
            // In processTag they will be stored in context and will be most likely used 
            // in child elements e.g. in items which are children of container
            Array.from(element.attributes).forEach(a => {
                let evaluation = evaluateAndCheckPrimitive(addContextToExpression(context, a.value));
                if(!evaluation.error)// && evaluation.isPrimitive)
                {
                    // console.log(a.localName + ".value was " + a.value + " and now is " + evaluation.result);
                    // a.value = evaluation.result;
                    context[a.localName] = evaluation.result;
                    // console.log("context[" + a.localName + "]=("+addContextToExpression(context, a.value)+")" + context[a.localname]);
                }
            });
            // console.log("After evalAttributesByContext context: ", context);
        }

        function processTag(context, element)
        {
            // attributes of #element# will be stored in the context and their value will replaced (before
            // evaluating) the corresponding 
            var contextDirectives = [
                {
                    element: "container", 
                    attributesToContext: [
                        { attribute: "container", contextProperty: 'c'}
                    ]
                },
                {
                    element: "item", 
                    attributesToContext: [
                        { attribute: "item", contextProperty: 'i'}
                    ]
                }
            ];
            const elementFiles = new Set(['container', 'item']);
            if(!contextDirectives.map(cd => cd.element).includes(element.localName))
            {
                return true;
            }
            // evalAttributesByContext(context, element);
            console.log("processTag for ", element, " with context ", context);

            let text = getContentsFromFile('static/elements/' + element.localName + '.html');
            if(!text.found)
            {
                console.log('No html file found for ' + element.localName + ' in static/elements');
                return true;
            }

            // let newContext = {...context};
            context = {...context};
            contextDirectives
                .find(cd => {return cd.element === element.localName;})
                .attributesToContext.forEach(a2c =>{
                    // copy computed values of attributes already stored in context with key = attribute.name
                    // into new (or existing) context keys for use in children of element
                    context[a2c.contextProperty] = context[a2c.attribute];
                });

            console.log("newContext: ", context);
            const template = document.createElement('template');
            template.innerHTML = text.response;
            // console.log(template.innerHTML);
            const result = template.content.children;
            console.log("result: ", result);
            // Array.from(template.content.children).forEach(c => {element.parentNode.appendChild(c);});
            
            // element = processElement(context, result[0]);
            // Array.from(result).slice(1).forEach(r => element.parentNode.appendChild(r));
            // console.log("removing ", element);
            // element.remove();
            // // Array.from(result).forEach(r => processElement(context, r));
            // return true;

            console.log("will append " + (result.length) + " children to parent ", element.parentNode, " of element ", element);
            for(let i = 0 ; i < result.length ; i++)
            {
                // console.log("appending ", result[i], " to ", element.parentNode);
                // element.parentNode.appendChild(result[i]);
                let e = processElement(context, result[i]);
                if(e != null)
                {
                    // e.id = c.guid;
                    console.log("appending ", e, " to ", element.parentNode);
                    element.parentNode.appendChild(e);
                }                
            }
            console.log("removing ", element);
            element.remove();
            // throw new Error('Forced stop');
            // let pn = element.parentNode;
            // element.remove();
            // Array.from(template.content.children).forEach(c => {
            //     console.log("in place of " + element.localName + " adding ", c);
            //     // element.parentNode.appendChild(c);
            // });
            return false;
        }

        function processElement(context, element)
        {
            const elementFiles = new Set(['container', 'item']);
            // console.log("Processing element: ", element, ", type: ", typeof element);
            if(!(element instanceof HTMLElement) || !('getAttribute' in element))
            {
                console.log("element is not HTMLElement or does not have 'getAttribute'. Exiting.");
                return element;
            }

            if(elementFiles.has(element.localName))
            {
                console.log("Processing element: ", element, " with context: ", context);
            }

            evalAttributesByContext(context, element);
            if(!evalIf(context, element))   //if true element was remmoved
            {
                return null;
            }
            let processChildren = true;
            evalValues(context, element);
            evalClass(context, element);
            evalTranslation(element);
            processChildren = processChildren && evalRepeat(context, element);
            processChildren = processChildren && processTag(context, element);
            if(processChildren)
            {
                Array.from(element.children).forEach((c) => {
                    // console.log("Will process ", c ," child of ", element);
                    processElement(context,c);
                });
            }
            return element;
        }

        function getContentsFromFile(filename)
        {
            // console.log("Getting contents of " + filename);
            let result = {response:  "", found: false};
            if (filename) {
                let cachedTemplate = null;
                // ahat: for some unknown reason deviceHtmlTemplateCache.filter(c => c.filenmame === filename)) does not work here, it returns nothing
                for(let i = 0 ; i < deviceHtmlTemplateCache.length ; i++)
                {
                    if(deviceHtmlTemplateCache[i].filename == filename)
                    {
                        cachedTemplate = deviceHtmlTemplateCache[i];
                        // console.log("Found match but deviceHtmlTemplateCache.filter says: ", deviceHtmlTemplateCache.filter(c => c.filenmame === filename))
                        break;
                    }
                }
                
                if(cachedTemplate != null )
                {
                    // console.log("Found cache of '" + filename + ": ", cachedTemplate);
                    result.response = cachedTemplate.text;
                    result.found = true;
                    return result;
                }

                xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if (this.readyState == 4) {
                        if (this.status == 200) 
                        {
                            result.response = this.responseText;
                            result.found = true;
                            deviceHtmlTemplateCache.push({filename: filename, text: this.responseText });
                        }
                        if (this.status == 404) 
                        {
                            console.log("Returning File not found.");
                            result.response = "File not found.";
                            result.found = false;
                        }
                    }
                }
                xhttp.open("GET", filename, false); //synchronous call
                xhttp.send();
                return result;
            }
            return "No file specified."
        }

        function generateContainerItemTree(containersList, parentId) {
                let containers = [];
                containersList.forEach(function(c) {
                    if (c.parentContainer === parentId) {
                        let container = createGuiContainer(c)
                        containers.push(container);                       
                    }
                });
                return containers;
            }

        function createGuiContainer(containerListElement)
        {
            return {
                guid: containerListElement.guid,
                parentContainer: containerListElement.parentContainer,
                name: containerListElement.containerName,
                containers: generateContainerItemTree(containersList, containerListElement.guid),
                items: items.filter(function(item){
                            return item.itemContainer == containerListElement.guid;
                        }),
                gui : {
                    collapsed: true,
                    allChildrenExpanded: false,
                    showMqttTopics: false,
                    filter: {
                        DOOR: true,
                        WINDOW: true,
                        LIGHT: true,
                        CLIMATE: true,
                        COVER: true,
                        ALARM: true,
                        CAMERA: true,
                        MOTION: true                        
                    }
                },
                expandAllChildren: function( expand ) { this.gui.collapsed = expand; for( let c = 0 ; c < this.containers.length ; c++ ) { this.containers[c].expandAllChildren( expand ); } }
            };
        }

        function addDeviceToItem( item )
        {
            switch( item.type )
            {
                case 'ALARM':
                    item.device = new Alarm( item.publish, item.subscribe, { main: 'ARMED_HOME' } );
                    break;
                case 'NET':
                    item.device = new Net( item.publish, { main: 'UNAVAILABLE' } );
                    break;
                case 'DOOR1':
                    item.device = new Door1( item.publish, { main: 'UNAVAILABLE' } );
                    break;
                case 'DOOR2R':                
                    item.device = new Door2R( item.publish, { left: 'OPEN', right: 'CLOSED', recline: 'OPEN' } );
                    break;
                case 'IPCAMERA':
                    item.device = new IPCamera( item.url );
                    break;
                case 'IPCAMERAPANTILT':
                    item.device = new IPCameraPanTilt( item.baseUrl, item.videostream, item.right, item.left, item.up, item.down, item.stop );
                    break;
                case 'LIGHT1':
                    item.device = new Light1( item.publish, item.subscribe, { state: 'UNAVAILABLE' } );
                    break;
                case 'LIGHT2':
                    item.device = new Light2( item.publish, item.subscribe, { left: 'ON', right: 'OFF' } );
                    break;
                case 'MOTIONCAMERA':
                    item.device = new MotionCamera( item.publish, item.subscribe, item.cameraId, item.videostream, 'UNAVAILABLE', 'NO_MOTION' );
                    break;
                case 'MOTIONCAMERAPANTILT':
                    item.device = new MotionCameraPanTilt( item.publish, item.subscribe, item.cameraId, item.videostream, 'UNAVAILABLE', 'NO_MOTION' );
                    break;
                case 'ROLLER1':
                    item.device = new Roller1( item.publish, { main: 'UNAVAILABLE' } );
                    break;
                case 'ROLLER1_AUTO':
                    item.device = new Roller1_Auto( item.publish, item.subscribe, { main: 'UNAVAILABLE', percent: -1 } );
                    break;
                case 'TEMPERATURE_HUMIDITY':
                    item.device = new TemperatureHumidity( item.publish, { main: 'ΟΝ', temperature: 20, humidity: 18 } );
                    break;
                case 'WINDOW1':
                    item.device = new Window1( item.publish, { main: 'UNAVAILABLE' });
                    break;
                case 'WINDOW1R':
                    item.device = new Window1R( item.publish, { main: 'UNAVAILABLE', recline: 'UNAVAILABLE' } );
                    break;
                case 'WINDOW2R':
                    item.device = new Window2R( item.publish, { left: 'UNAVAILABLE', right: 'UNAVAILABLE', recline: 'UNAVAILABLE' } );
                    break;
                case 'MODEM':
                    item.device = new Modem( item.publish, item.subscribe, {} );
                    break;
                case 'SMS':
                    item.device = new Sms( item.publish, item.subscribe, {} );
                    break;
            }
        }

    </script>
</head>
<body>
    <div id="content">
        <div class="servers">
            <div ng-repeat="s in mqttServers">
                <server server="s"></server>
            </div>
        </div>
        <div ng-repeat="o in containers">
            <container container='o' level="1" show-label="true" expandAllChildren="true" is-collapsed-house="false" filter="filter" show-mqtt-topics="showMqttTopics"/>
        </div>
    </div>
</body>
</html>